#!/usr/bin/perl -W

require CRS::Auphonic;
require C3TT::Client;
require boolean;
use File::Basename qw(dirname);
use File::Spec qw(rel2abs);
use Data::Dumper;

my ($secret, $token) = ($ENV{'CRS_SECRET'}, $ENV{'CRS_TOKEN'});

if (!defined($token)) {
	# print usage
	print STDERR "Too few information given!\n\n";
	print STDERR "set environment variables CRS_SECRET and CRS_TOKEN\n\n";
	exit 1;
}

# fetch ticket ready to state postencoding, thus ready to be transmitted to auphonic
my $tracker = C3TT::Client->new();
my $ticket = $tracker->assignNextUnassignedForState('encoding','postencoding');
my $didsomething = 0;

if (!defined($ticket) || ref($ticket) eq 'boolean' || $ticket->{id} <= 0) {
	print "currently no tickets for postencoding\n";
} else {
	my $tid = $ticket->{id};
	my $props = $tracker->getTicketProperties($tid);
	my $vid = $props->{'Fahrplan.ID'};
	print "got ticket # $tid for event $vid\n";

	my $auphonicflag = 'no';
	$auphonicflag = $props->{'Processing.UseAuphonic'} if defined ($props->{'Processing.UseAuphonic'});
	$auphonicflag = 'no' unless (defined ($props->{'Processing.Auphonic.Enable'}));
	$auphonicflag = $props->{'Processing.Auphonic.Enable'} if (defined ($props->{'Processing.Auphonic.Enable'}) && $auphonicflag eq 'yes');

	if ($auphonicflag ne 'yes') {
		my $jobfile = $tracker->getJobFile($tid);
		utf8::encode($jobfile);
		my $jobfilePath = $props->{'Processing.Path.Tmp'}.'/job-'.$tid.'-foo.xml';

		# download jobfile into a physical file
		open(my $file, ">", $jobfilePath) or die $!;
		print $file "$jobfile";
		close $file;

		# locate exmljob-filtered.pl by tracker property
		my $perlPath = $props->{'Processing.Path.Exmljob'};
		if (!defined($perlPath) || $perlPath eq '') {
			# try some fallback
			$perlPath = dirname(File::Spec->rel2abs( __FILE__ )) . '/../../job-control/exmljob-filtered.pl';
			if (! -f $perlPath) {
				print STDERR "Processing.Path.Exmljob is missing!";
				sleep 5;
				die;
			}
		}
	
		# execute exmljob-filtered.pl with the downloaded jobfile
		my $perlDir = dirname($perlPath);
		chdir $perlDir;
		$output = qx ( perl "$perlPath" -t postencoding "$jobfilePath" );
		if ($?) {
			$tracker->setTicketFailed($tid, "postencoding failed! Status: $? Output: '$output'");
			die;
		}
		unlink($jobfilePath);
		$tracker->setTicketDone($tid, 'postencoding executed successfully');
		# indicate short sleep to wrapper script
		exit(100);
	}
	# auphonic authentication via token - the token is stored as a project property in the tracker
	my $auphonicToken = $props->{'Processing.Auphonic.Token'};

	# the chosen auphonic preset configures all filters
	my $auphonicPreset = $props->{'Processing.Auphonic.Preset'};

	# demuxed mp2 in mpeg-ts as generated by the encoding-profile
	# TODO get filename in a flexible way, perhaps property
	my $audio1 = $props->{'Processing.Path.Tmp'}.'/'.$vid.'-'.$props->{'EncodingProfile.Slug'}.'-audio1.ts';
	my $auphonic = CRS::Auphonic->new($auphonicToken);

	if (defined($props->{'Processing.Auphonic.SpeedLimit'})) {
		$auphonic->setSpeedLimit($props->{'Processing.Auphonic.SpeedLimit'});
	}

	# upload audio-file to auphonic and start the production
	print "Starting production for audio track 1\n";
	my $auphonic_1 = $auphonic->startProduction($auphonicPreset, $audio1, $props->{'Project.Slug'}.'-'.$vid.'-audio1') or die $!;

	if (!defined($auphonic_1)) {
		print STDERR "Starting production for audio track 1 failed!\n";
		$tracker->setTicketFailed($tid, "Starting production for audio track 1 failed!");
		die;
	}

	# fetch the auphonic production uuid and store it into a tracker property
	my $uuid1 = $auphonic_1->getUUID();
	print "Started production for audio track 1 as '$uuid1'\n";
	my %props_new = (
		'Processing.Auphonic.ProductionID1' => $uuid1,
	);

	# test if the talk has been marked as having a second audio track
	my $lang = $props->{'Record.Language'};
	$lang = '' unless defined($lang);
	if ($lang =~ /^..-../) {
		# demuxed mp2 in mpeg-ts as generated by the encoding-profile
		$audio2 = $props->{'Processing.Path.Tmp'}.'/'.$vid.'-'.$props->{'EncodingProfile.Slug'}.'-audio2.ts';

		# upload audio-file to auphonic and start the production
		print "Starting production for audio track 2\n";
		my $auphonic_2 = $auphonic->startProduction($auphonicPreset, $audio2, $props->{'Project.Slug'}.'-'.$vid.'-audio2') or die $!;

		if (!defined($auphonic_2)) {
			$tracker->setTicketFailed($tid, "Starting production for audio track 2 failed!");
			die;
		}

		# fetch the auphonic production uuid and store it into a tracker property
		my $uuid2 = $auphonic_2->getUUID();
		print "Started production for audio track 2 as '$uuid2'\n";
		$props_new{'Processing.Auphonic.ProductionID2'} = $uuid2;
	}

	# upload changed properties to tracker
	$tracker->setTicketProperties($tid, \%props_new);
	$didsomething = 1;
}

# query tickets that are in postencoding state and assigned to this worker
print "querying for assigned ticket in state postencoding ...\n";
my $tickets = $tracker->getAssignedForState('encoding', 'postencoding');

if (!($tickets) || 0 == scalar(@$tickets)) {
	print "no assigned tickets currently postencoding. exiting...\n";
	exit 0;
}

print "found " . scalar(@$tickets) ." tickets\n";
foreach (@$tickets) {
	my $ticket = $_;
	my $tid = $ticket->{id};
	my $props = $tracker->getTicketProperties($tid);
	my $vid = $props->{'Fahrplan.ID'};
	print "got ticket # $tid for event $vid\n";

	# auphonic login token and uuids of the auphonic productions
	my $auphonicToken = $props->{'Processing.Auphonic.Token'};
	my $uuid1 = $props->{'Processing.Auphonic.ProductionID1'};
	my $uuid2 = $props->{'Processing.Auphonic.ProductionID2'};

	if (!defined($auphonicToken) || !defined($uuid1)) {
		$tracker->setTicketFailed($tid, 'stale postencoding ticket or Auphonic upload failed!');
		next;
	}

	# poll production states
	my $a1 = CRS::Auphonic->new($auphonicToken, $uuid1);
	if (!$a1->isFinished()) {
		print "production $uuid1 not done yet.. skipping\n";
		next;
	}
	my $a2 = undef;
	if (defined($uuid2)) {
		$a2 = CRS::Auphonic->new($auphonicToken, $uuid2);
		if (!$a2->isFinished()) {
			print "production $uuid2 not done yet.. skipping\n";
			next;
		}
	}

	# download audio files
	my $dest1 = $props->{'Processing.Path.Tmp'}.'/'.$vid.'-'.$props->{'EncodingProfile.Slug'}.'-audio1-auphonic.m4a';
	my $dest2 = $props->{'Processing.Path.Tmp'}.'/'.$vid.'-'.$props->{'EncodingProfile.Slug'}.'-audio2-auphonic.m4a';

	print "downloading audio track 1 from Auphonic... to $dest1\n";
	if (!$a1->downloadResult($dest1)) {
		$tracker->setTicketFailed($tid, 'download of audio track 1 from auphonic failed!');
	}
	if (defined($uuid2)) {
		print "downloading audio track 2 from Auphonic... to $dest2\n";
		if (!$a2->downloadResult($dest2)) {
			$tracker->setTicketFailed($tid, 'download of audio track 2 from auphonic failed!');
		}
	}

	# remux via encoding profile job of type "remux"
	print "remuxing audio tracks...\n";
	my $jobfile = $tracker->getJobFile($tid);
	utf8::encode($jobfile);
	my $jobfilePath = $props->{'Processing.Path.Tmp'}.'/job-'.$tid.'.xml';

	# download jobfile into a physical file
	open(my $file, ">", $jobfilePath) or die $!;
	print $file "$jobfile";
	close $file;

	# locate exmljob-filtered.pl by tracker property
	my $perlPath = $props->{'Processing.Path.Exmljob'};
	if (!defined($perlPath) || $perlPath eq '') {
		# try some fallback
		$perlPath = dirname(File::Spec->rel2abs( __FILE__ )) . '/../../job-control/exmljob-filtered.pl';
		if (! -f $perlPath) {
			print STDERR "Processing.Path.Exmljob is missing!";
			sleep 5;
			die;
		}
	}

	# execute exmljob-filtered.pl with the downloaded jobfile
	my $perlDir = dirname($perlPath);
	chdir $perlDir;
	$output = qx ( perl "$perlPath" -t remux "$jobfilePath" );
	if ($?) {
		$tracker->setTicketFailed($tid, "remuxing failed! Status: $? Output: '$output'");
		die;
	}

	# done
	$tracker->setTicketDone($tid);
	$didsomething = 1;
	unlink($jobfilePath);
	print "sleeping a while...\n";
	sleep 5;
}

if ($didsomething == 1) {
	exit(100);
}

