#!/usr/bin/perl -W

require CRS::Auphonic;
require C3TT::Client;
require boolean;
use File::Basename qw(dirname);
use File::Spec::Functions qw(rel2abs);
use Digest::MD5;
use Data::Dumper;


sub getMD5 {
	my $filename = shift;
	my $languages = shift;
	open (my $fh, '<', $filename) or die "Can't open '$filename': $!";
	binmode ($fh);
	my $hash = Digest::MD5->new->addfile($fh)->hexdigest;
	my $languageCount = scalar(keys(%{$languages}));
	return $hash . '-' . $languageCount;
}

sub getLanguages {
	my $props = shift;
	my %languages;
	foreach my $key (keys %{$props}) {
		if ($key =~ /^Record.Language.(\d+)$/) {
			$languages{$1} = $props->{$key};
			print "found language $1 " . $props->{$key} . "\n";
		}
	}
	return %languages;
}

sub getPerlPath {
	my $props = shift;
	# locate exmljob-filtered.pl by tracker property
	my $perlPath = $props->{'Processing.Path.Exmljob'};
	if (!defined($perlPath) || $perlPath eq '' || ! -f $perlPath) {
		# try some fallback
		$perlPath = dirname(File::Spec->rel2abs( __FILE__ )) . '/../../job-control/exmljob-filtered.pl';
		if (! -f $perlPath) {
			print STDERR "Processing.Path.Exmljob is missing!";
			sleep 5;
			die;
		}
	}
	return $perlPath;
}


my ($secret, $token) = ($ENV{'CRS_SECRET'}, $ENV{'CRS_TOKEN'});

if (!defined($token)) {
	# print usage
	print STDERR "Too few information given!\n\n";
	print STDERR "set environment variables CRS_SECRET and CRS_TOKEN\n\n";
	exit 1;
}

# fetch ticket ready to state postencoding, thus ready to be transmitted to auphonic
my $tracker = C3TT::Client->new();
my $ticket = $tracker->assignNextUnassignedForState('encoding','postencoding');
my $didsomething = 0;

if (!defined($ticket) || ref($ticket) eq 'boolean' || $ticket->{id} <= 0) {
	print "currently no tickets for postencoding\n";
} else {
	my $tid = $ticket->{id};
	my $props = $tracker->getTicketProperties($tid);
	my $vid = $props->{'Fahrplan.ID'};
	print "got ticket # $tid for event $vid\n";

	my $auphonicflag = 'no';
	$auphonicflag = $props->{'Processing.UseAuphonic'} if defined ($props->{'Processing.UseAuphonic'});
	$auphonicflag = 'no' unless (defined ($props->{'Processing.Auphonic.Enable'}));
	$auphonicflag = $props->{'Processing.Auphonic.Enable'} if (defined ($props->{'Processing.Auphonic.Enable'}) && $auphonicflag eq 'yes');

	if ($auphonicflag ne 'yes') {
		my $jobfile = $tracker->getJobFile($tid);
		utf8::encode($jobfile);
		my $jobfilePath = $props->{'Processing.Path.Tmp'}.'/job-'.$tid.'-foo.xml';

		# download jobfile into a physical file
		open(my $file, ">", $jobfilePath) or die $!;
		print $file "$jobfile";
		close $file;

		# locate exmljob-filtered.pl by tracker property
		my $perlPath = getPerlPath($props);
	
		# execute exmljob-filtered.pl with the downloaded jobfile
		my $perlDir = dirname($perlPath);
		chdir $perlDir;
		$output = qx ( perl "$perlPath" -t postencoding "$jobfilePath" );
		if ($?) {
			$tracker->setTicketFailed($tid, "postencoding failed! Status: $? Output: '$output'");
			die;
		}
		unlink($jobfilePath);
		$tracker->setTicketDone($tid, 'postencoding executed successfully');
		# indicate short sleep to wrapper script
		exit(100);
	}

	# extract languages from properties into separate hash
	my %languages = getLanguages($props);

	# check if there is already a production and if the file changed since then
	my $oldMD5 = $props->{'Processing.Auphonic.SourceFileHash'};
	my $sourcefile = $props->{'Processing.Path.Tmp'}.'/'.$vid.'-'.$props->{'EncodingProfile.Slug'}.".".$props->{'EncodingProfile.Extension'};
	if (! -f $sourcefile) {
		print STDERR "WARNING: no source file found ('$sourcefile'), possibly repeating production uneccessarily\n";
		($oldMD5, $sourcefile) = (undef, undef);
	}

	my $isIdentical = 0;
	my $newMD5 = getMD5($sourcefile, \%languages) if defined($sourcefile);
	if (defined($oldMD5) && defined($newMD5) && $oldMD5 eq $newMD5) {
		$isIdentical = 1;
		print "source file did not change, not repeating productions\n";
	}

	# auphonic authentication via token - the token is stored as a project property in the tracker
	my $auphonicToken = $props->{'Processing.Auphonic.Token'};

	# the chosen auphonic preset configures all filters
	my $auphonicPreset = $props->{'Processing.Auphonic.Preset'};

	# demuxed mp2 in mpeg-ts as generated by the encoding-profile
	my $auphonic = CRS::Auphonic->new($auphonicToken);

	if (defined($props->{'Processing.Auphonic.SpeedLimit'})) {
		$auphonic->setSpeedLimit($props->{'Processing.Auphonic.SpeedLimit'});
	}

	my %props_new = ( );
	$props_new{'Processing.Auphonic.SourceFileHash'} = $newMD5 if defined($newMD5);

	# upload audio-file(s) to auphonic and start the production, if source file changed
	if ($isIdentical == 0) {
		foreach my $langIndex (keys %languages) {
			$langIndex += 1; # currently the filename indexes start with 1 and not 0
			my $audioSrcFile = $props->{'Processing.Path.Tmp'}.'/'.
				$vid.'-'.$props->{'EncodingProfile.Slug'}.'-audio'.$langIndex.'.ts';
			print "Starting production for audio track $langIndex\n";
			my $auphonic = $auphonic->startProduction($auphonicPreset, $audioSrcFile, 
				$props->{'Project.Slug'}.'-'.$vid.'-audio'.$langIndex) or die $!;
			if (!defined($auphonic)) {
				print STDERR "Starting production for audio track $langIndex failed!\n";
				$tracker->setTicketFailed($tid, "Starting production for audio track $langIndex failed!");
				die;
			}
			my $uuid = $auphonic->getUUID();
			print "Started production for audio track $langIndex as '$uuid'\n";
			$props_new{'Processing.Auphonic.ProductionID'.$langIndex} = $uuid;
		}
		# upload changed properties to tracker
		$tracker->setTicketProperties($tid, \%props_new);
		$didsomething = 1;
	} else {
		print "not repeating auphonic production for recording of '$vid'\n";
	}

}

# query tickets that are in postencoding state and assigned to this worker
print "querying for assigned ticket in state postencoding ...\n";
my $tickets = $tracker->getAssignedForState('encoding', 'postencoding');

if (!($tickets) || 0 == scalar(@$tickets)) {
	print "no assigned tickets currently postencoding. exiting...\n";
	exit 0;
}

print "found " . scalar(@$tickets) ." tickets\n";
foreach (@$tickets) {
	my $ticket = $_;
	my $tid = $ticket->{id};
	my $props = $tracker->getTicketProperties($tid);
	my $vid = $props->{'Fahrplan.ID'};
	print "got ticket # $tid for event $vid\n";

	# auphonic login token and uuids of the auphonic productions
	my $auphonicToken = $props->{'Processing.Auphonic.Token'};
	if (!defined($auphonicToken)) {
		$tracker->setTicketFailed($tid, 'Stale postencoding ticket? No Auphonic Token!');
		next;
	}

	# extract languages from properties into separate hash
	my %languages = getLanguages($props);

	my $incomplete = 0;
	foreach my $langIndex (keys %languages) {
		$langIndex += 1; # currently the filename indexes start with 1 and not 0
		my $uuid = $props->{'Processing.Auphonic.ProductionID'.$langIndex};
		if (!defined($uuid)) {
			$tracker->setTicketFailed($tid, 'Stale postencoding ticket? No Auphonic UUID!');
			$incomplete = 1;
			last;
		}
		# poll production states
		my $auphonic = CRS::Auphonic->new($auphonicToken, $uuid);
		if (!$auphonic->isFinished()) {
			print "production $uuid not done yet.. skipping\n";
			$incomplete = 1;
			last;
		}
		my $dest = $props->{'Processing.Path.Tmp'}.'/'.$vid.'-'.$props->{'EncodingProfile.Slug'}.
			'-audio'.$langIndex.'-auphonic.m4a';
		print "downloading audio track $langIndex from Auphonic... to '$dest'\n";
		if (!$auphonic->downloadResult($dest)) {
			$tracker->setTicketFailed($tid, "download of audio track $langIndex from auphonic failed!");
			$incomplete = 1;
			last;
		}
	}

	if ($incomplete == 1) {
		next;
	}

	# remux via encoding profile job of type "remux"
	print "remuxing audio tracks...\n";
	my $jobfile = $tracker->getJobFile($tid);
	utf8::encode($jobfile);
	my $jobfilePath = $props->{'Processing.Path.Tmp'}.'/job-'.$tid.'.xml';

	# download jobfile into a physical file
	open(my $file, ">", $jobfilePath) or die $!;
	print $file "$jobfile";
	close $file;

	# locate exmljob-filtered.pl by tracker property
	my $perlPath = getPerlPath($props);

	# execute exmljob-filtered.pl with the downloaded jobfile
	my $perlDir = dirname($perlPath);
	chdir $perlDir;
	$output = qx ( perl "$perlPath" -t remux "$jobfilePath" );
	if ($?) {
		$tracker->setTicketFailed($tid, "remuxing failed! Status: $? Output: '$output'");
		die;
	}

	# done
	$tracker->setTicketDone($tid);
	$didsomething = 1;
	unlink($jobfilePath);
	print "sleeping a while...\n";
	sleep 5;
}

if ($didsomething == 1) {
	exit(100);
}

